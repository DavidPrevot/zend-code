{
    "docs": [
        {
            "location": "/",
            "text": "zend-code\n\n\n\n\n\n\nZend\\Code\\Generator\n provides facilities to generate arbitrary code using an\nobject-oriented interface, both to create new code as well as to update existing\ncode. While the current implementation is limited to generating PHP code, you\ncan easily extend the base class in order to provide code generation for other\ntasks: JavaScript, configuration files, apache vhosts, etc.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-code/issues\n\n\nDocumentation is at http://zend-code.rtfd.org\n\n\nMigration documentation from v2 to v3 is at http://zend-code.rtfd.org/en/latest/migration/",
            "title": "Home"
        },
        {
            "location": "/#zend-code",
            "text": "Zend\\Code\\Generator  provides facilities to generate arbitrary code using an\nobject-oriented interface, both to create new code as well as to update existing\ncode. While the current implementation is limited to generating PHP code, you\ncan easily extend the base class in order to provide code generation for other\ntasks: JavaScript, configuration files, apache vhosts, etc.   File issues at https://github.com/zendframework/zend-code/issues  Documentation is at http://zend-code.rtfd.org  Migration documentation from v2 to v3 is at http://zend-code.rtfd.org/en/latest/migration/",
            "title": "zend-code"
        },
        {
            "location": "/generator/intro/",
            "text": "Introduction\n\n\nZend\\Code\\Generator\n provides facilities to generate arbitrary code using an object-oriented\ninterface, both to create new code as well as to update existing code. While the current\nimplementation is limited to generating \nPHP\n code, you can easily extend the base class in order to\nprovide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc.\n\n\nTheory of Operation\n\n\nIn the most typical use case, you will simply instantiate a code generator class and either pass it\nthe appropriate configuration or configure it after instantiation. To generate the code, you will\nsimply echo the object or call its \ngenerate()\n method.\n\n\n// Passing configuration to the constructor:\n$file = new Zend\\Code\\Generator\\FileGenerator(array(\n    'classes' => array(\n        new Zend\\Code\\Generator\\ClassGenerator(\n            'World',  // name\n            null,     // namespace\n            null,     // flags\n            null,     // extends\n            array(),  // interfaces\n            array(),  // properties\n            array(\n                new Zend\\Code\\Generator\\MethodGenerator(\n                    'hello',                  // name\n                    array(),                  // parameters\n                    'public',                 // visibility\n                    'echo \\'Hello world!\\';'  // body\n                ),\n            )\n        ),\n    ),\n));\n\n// Render the generated file\necho $file->generate();\n\n// or write it to a file:\nfile_put_contents('World.php', $file->generate());\n\n// OR\n\n// Configuring after instantiation\n$method = new Zend\\Code\\Generator\\MethodGenerator();\n$method->setName('hello')\n       ->setBody('echo \\'Hello world!\\';');\n\n$class = new Zend\\Code\\Generator\\ClassGenerator();\n$class->setName('World')\n      ->addMethodFromGenerator($method);\n\n$file = new Zend\\Code\\Generator\\FileGenerator();\n$file->setClass($class);\n\n// Render the generated file\necho $file->generate();\n\n// or write it to a file:\nfile_put_contents('World.php', $file->generate());\n\n\n\nBoth of the above samples will render the same result:\n\n\n<?php\n\nclass World\n{\n\n    public function hello()\n    {\n        echo 'Hello world!';\n    }\n\n}\n\n\n\nAnother common use case is to update existing code -- for instance, to add a method to a class. In\nsuch a case, you must first inspect the existing code using reflection, and then add your new\nmethod. \nZend\\Code\\Generator\n makes this trivially simple, by leveraging \nZend\\Code\\Reflection\n.\n\n\nAs an example, let's say we've saved the above to the file \nWorld.php\n, and have already included\nit. We could then do the following:\n\n\n$class = Zend\\Code\\Generator\\ClassGenerator::fromReflection(\n    new Zend\\Code\\Reflection\\ClassReflection('World')\n);\n\n$method = new Zend\\Code\\Generator\\MethodGenerator();\n$method->setName('mrMcFeeley')\n       ->setBody('echo \\'Hello, Mr. McFeeley!\\';');\n$class->addMethodFromGenerator($method);\n\n$file = new Zend\\Code\\Generator\\FileGenerator();\n$file->setClass($class);\n\n// Render the generated file\necho $file->generate();\n\n// Or, better yet, write it back to the original file:\nfile_put_contents('World.php', $file->generate());\n\n\n\nThe resulting class file will now look like this:\n\n\n<?php\n\nclass World\n{\n\n    public function hello()\n    {\n        echo 'Hello world!';\n    }\n\n    public function mrMcFeeley()\n    {\n        echo 'Hellow Mr. McFeeley!';\n    }\n\n}",
            "title": "Intro"
        },
        {
            "location": "/generator/intro/#introduction",
            "text": "Zend\\Code\\Generator  provides facilities to generate arbitrary code using an object-oriented\ninterface, both to create new code as well as to update existing code. While the current\nimplementation is limited to generating  PHP  code, you can easily extend the base class in order to\nprovide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc.",
            "title": "Introduction"
        },
        {
            "location": "/generator/intro/#theory-of-operation",
            "text": "In the most typical use case, you will simply instantiate a code generator class and either pass it\nthe appropriate configuration or configure it after instantiation. To generate the code, you will\nsimply echo the object or call its  generate()  method.  // Passing configuration to the constructor:\n$file = new Zend\\Code\\Generator\\FileGenerator(array(\n    'classes' => array(\n        new Zend\\Code\\Generator\\ClassGenerator(\n            'World',  // name\n            null,     // namespace\n            null,     // flags\n            null,     // extends\n            array(),  // interfaces\n            array(),  // properties\n            array(\n                new Zend\\Code\\Generator\\MethodGenerator(\n                    'hello',                  // name\n                    array(),                  // parameters\n                    'public',                 // visibility\n                    'echo \\'Hello world!\\';'  // body\n                ),\n            )\n        ),\n    ),\n));\n\n// Render the generated file\necho $file->generate();\n\n// or write it to a file:\nfile_put_contents('World.php', $file->generate());\n\n// OR\n\n// Configuring after instantiation\n$method = new Zend\\Code\\Generator\\MethodGenerator();\n$method->setName('hello')\n       ->setBody('echo \\'Hello world!\\';');\n\n$class = new Zend\\Code\\Generator\\ClassGenerator();\n$class->setName('World')\n      ->addMethodFromGenerator($method);\n\n$file = new Zend\\Code\\Generator\\FileGenerator();\n$file->setClass($class);\n\n// Render the generated file\necho $file->generate();\n\n// or write it to a file:\nfile_put_contents('World.php', $file->generate());  Both of the above samples will render the same result:  <?php\n\nclass World\n{\n\n    public function hello()\n    {\n        echo 'Hello world!';\n    }\n\n}  Another common use case is to update existing code -- for instance, to add a method to a class. In\nsuch a case, you must first inspect the existing code using reflection, and then add your new\nmethod.  Zend\\Code\\Generator  makes this trivially simple, by leveraging  Zend\\Code\\Reflection .  As an example, let's say we've saved the above to the file  World.php , and have already included\nit. We could then do the following:  $class = Zend\\Code\\Generator\\ClassGenerator::fromReflection(\n    new Zend\\Code\\Reflection\\ClassReflection('World')\n);\n\n$method = new Zend\\Code\\Generator\\MethodGenerator();\n$method->setName('mrMcFeeley')\n       ->setBody('echo \\'Hello, Mr. McFeeley!\\';');\n$class->addMethodFromGenerator($method);\n\n$file = new Zend\\Code\\Generator\\FileGenerator();\n$file->setClass($class);\n\n// Render the generated file\necho $file->generate();\n\n// Or, better yet, write it back to the original file:\nfile_put_contents('World.php', $file->generate());  The resulting class file will now look like this:  <?php\n\nclass World\n{\n\n    public function hello()\n    {\n        echo 'Hello world!';\n    }\n\n    public function mrMcFeeley()\n    {\n        echo 'Hellow Mr. McFeeley!';\n    }\n\n}",
            "title": "Theory of Operation"
        },
        {
            "location": "/generator/examples/",
            "text": "Zend\\Code\\Generator Examples\n\n\nGenerating PHP classes\n\n\nThe following example generates an empty class with a class-level DocBlock.\n\n\nuse Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock);\necho $foo->generate();\n\n\n\nThe above code will result in the following:\n\n\n/**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n *\n */\nclass Foo\n{\n\n}\n\n\n\nGenerating PHP classes with class properties\n\n\nBuilding on the previous example, we now add properties to our generated class.\n\n\nuse Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\PropertyGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock)\n    ->addProperties([\n         ['_bar', 'baz', PropertyGenerator::FLAG_PROTECTED],\n         ['baz',  'bat', PropertyGenerator::FLAG_PUBLIC]\n   ])\n   ->addConstants([\n         ['bat',  'foobarbazbat']\n    ]);\necho $foo->generate();\n\n\n\nThe above results in the following class definition:\n\n\n/**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n *\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n}\n\n\n\nGenerating PHP classes with class methods\n\n\nZend\\Code\\Generator\\ClassGenerator\n allows you to attach methods with optional content to your\nclasses. Methods may be attached as either arrays or concrete \nZend\\Code\\Generator\\MethodGenerator\n\ninstances.\n\n\nuse Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\DocBlock\\Tag;\nuse Zend\\Code\\Generator\\MethodGenerator;\nuse Zend\\Code\\Generator\\PropertyGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock)\n    ->addProperties([\n        ['_bar', 'baz',          PropertyGenerator::FLAG_PROTECTED],\n        ['baz',  'bat',          PropertyGenerator::FLAG_PUBLIC]\n    ])\n    ->addConstants([\n        ['bat',  'foobarbazbat', PropertyGenerator::FLAG_CONSTANT]\n    ])\n    ->addMethods([\n        // Method passed as array\n        MethodGenerator::fromArray([\n            'name'       => 'setBar',\n            'parameters' => ['bar'],\n            'body'       => '$this->_bar = $bar;' . \"\\n\" . 'return $this;',\n            'docblock'   => DocBlockGenerator::fromArray([\n                'shortDescription' => 'Set the bar property',\n                'longDescription'  => null,\n                'tags'             => [\n                    new Tag\\ParamTag([\n                        'paramName' => 'bar',\n                        'datatype'  => 'string'\n                    ]),\n                    new Tag\\ReturnTag([\n                        'datatype'  => 'string',\n                    ]),\n                ],\n            ]),\n        ]),\n        // Method passed as concrete instance\n        new MethodGenerator(\n            'getBar',\n            [],\n            MethodGenerator::FLAG_PUBLIC,\n            'return $this->_bar;',\n            DocBlockGenerator::fromArray([\n                'shortDescription' => 'Retrieve the bar property',\n                'longDescription'  => null,\n                'tags'             => [\n                    new Tag\\ReturnTag([\n                        'datatype'  => 'string|null',\n                    ]),\n                ],\n            ])\n        ),\n    ]);\n\necho $foo->generate();\n\n\n\nThe above generates the following output:\n\n\n/**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n    /**\n     * Set the bar property\n     *\n     * @param string bar\n     * @return string\n     */\n    public function setBar($bar)\n    {\n        $this->_bar = $bar;\n        return $this;\n    }\n\n    /**\n     * Retrieve the bar property\n     *\n     * @return string|null\n     */\n    public function getBar()\n    {\n        return $this->_bar;\n    }\n\n}\n\n\n\nGenerating PHP files\n\n\nZend\\Code\\Generator\\FileGenerator\n can be used to generate the contents of a \nPHP\n file. You can\ninclude classes as well as arbitrary content body. When attaching classes, you should attach either\nconcrete \nZend\\Code\\Generator\\ClassGenerator\n instances or an array defining the class.\n\n\nIn the example below, we will assume you've defined \n$foo\n per one of the class definitions in a\nprevious example.\n\n\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\FileGenerator;\n\n$file = FileGenerator::fromArray([\n    'classes'  => [$foo],\n    'docblock' => DocBlockGenerator::fromArray([\n        'shortDescription' => 'Foo class file',\n        'longDescription'   => null,\n        'tags'             => [\n            [\n                'name'        => 'license',\n                'description' => 'New BSD',\n            ],\n        ],\n    ]),\n    'body'     => 'define(\\'APPLICATION_ENV\\', \\'testing\\');',\n]);\n\n\n\nCalling \ngenerate()\n will generate the code -- but not write it to a file. You will need to capture\nthe contents and write them to a file yourself. As an example:\n\n\n$code = $file->generate();\nfile_put_contents('Foo.php', $code);\n\n\n\nThe above will generate the following file:\n\n\n<?php\n/**\n * Foo class file\n *\n * @license New BSD\n */\n\n/**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n    /**\n     * Set the bar property\n     *\n     * @param string bar\n     * @return string\n     */\n    public function setBar($bar)\n    {\n        $this->_bar = $bar;\n        return $this;\n    }\n\n    /**\n     * Retrieve the bar property\n     *\n     * @return string|null\n     */\n    public function getBar()\n    {\n        return $this->_bar;\n    }\n\n}\n\ndefine('APPLICATION_ENV', 'testing');\n\n\n\nAdd code to existing PHP files and classes\n\n\nSeeding PHP file code generation via reflection\n\n\nYou can add \nPHP\n code to an existing \nPHP\n file using the code generator. To do so, you need to\nfirst do reflection on it. The static method \nfromReflectedFileName()\n allows you to do this.\n\n\n$generator = Zend\\Code\\Generator\\FileGenerator::fromReflectedFileName($path);   \n$generator->setBody(\"\\$foo->bar();\");\nfile_put_contents($path, $generator->generate());\n\n\n\nSeeding PHP class generation via reflection\n\n\nYou may add code to an existing class. To do so, first use the static \nfromReflection()\n method to\nmap the class into a generator object. From there, you may add additional properties or methods, and\nthen regenerate the class.\n\n\nuse Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\DocBlock\\Tag;\nuse Zend\\Code\\Generator\\MethodGenerator;\nuse Zend\\Code\\Reflection\\ClassReflection;\n\n$generator = ClassGenerator::fromReflection(\n    new ClassReflection($class)\n);\n$generator->addMethod(\n    'setBaz',\n    ['baz'],\n    MethodGenerator::FLAG_PUBLIC,\n    '$this->_baz = $baz;' . \"\\n\" . 'return $this;',\n    DocBlockGenerator::fromArray([\n        'shortDescription' => 'Set the baz property',\n        'longDescription'  => null,\n        'tags'             => [\n            new Tag\\ParamTag([\n                'paramName' => 'baz',\n                'datatype'  => 'string'\n            ]),\n            new Tag\\ReturnTag([\n                'datatype'  => 'string',\n            ]),\n        ],\n    ])\n);\n$code = $generator->generate();",
            "title": "Examples"
        },
        {
            "location": "/generator/examples/#zend92code92generator-examples",
            "text": "",
            "title": "Zend\\Code\\Generator Examples"
        },
        {
            "location": "/generator/examples/#generating-php-classes",
            "text": "The following example generates an empty class with a class-level DocBlock.  use Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock);\necho $foo->generate();  The above code will result in the following:  /**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n *\n */\nclass Foo\n{\n\n}",
            "title": "Generating PHP classes"
        },
        {
            "location": "/generator/examples/#generating-php-classes-with-class-properties",
            "text": "Building on the previous example, we now add properties to our generated class.  use Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\PropertyGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock)\n    ->addProperties([\n         ['_bar', 'baz', PropertyGenerator::FLAG_PROTECTED],\n         ['baz',  'bat', PropertyGenerator::FLAG_PUBLIC]\n   ])\n   ->addConstants([\n         ['bat',  'foobarbazbat']\n    ]);\necho $foo->generate();  The above results in the following class definition:  /**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n *\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n}",
            "title": "Generating PHP classes with class properties"
        },
        {
            "location": "/generator/examples/#generating-php-classes-with-class-methods",
            "text": "Zend\\Code\\Generator\\ClassGenerator  allows you to attach methods with optional content to your\nclasses. Methods may be attached as either arrays or concrete  Zend\\Code\\Generator\\MethodGenerator \ninstances.  use Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\DocBlock\\Tag;\nuse Zend\\Code\\Generator\\MethodGenerator;\nuse Zend\\Code\\Generator\\PropertyGenerator;\n\n$foo      = new ClassGenerator();\n$docblock = DocBlockGenerator::fromArray([\n    'shortDescription' => 'Sample generated class',\n    'longDescription'  => 'This is a class generated with Zend\\Code\\Generator.',\n    'tags'             => [\n        [\n            'name'        => 'version',\n            'description' => '$Rev:$',\n        ],\n        [\n            'name'        => 'license',\n            'description' => 'New BSD',\n        ],\n    ],\n]);\n$foo->setName('Foo')\n    ->setDocblock($docblock)\n    ->addProperties([\n        ['_bar', 'baz',          PropertyGenerator::FLAG_PROTECTED],\n        ['baz',  'bat',          PropertyGenerator::FLAG_PUBLIC]\n    ])\n    ->addConstants([\n        ['bat',  'foobarbazbat', PropertyGenerator::FLAG_CONSTANT]\n    ])\n    ->addMethods([\n        // Method passed as array\n        MethodGenerator::fromArray([\n            'name'       => 'setBar',\n            'parameters' => ['bar'],\n            'body'       => '$this->_bar = $bar;' . \"\\n\" . 'return $this;',\n            'docblock'   => DocBlockGenerator::fromArray([\n                'shortDescription' => 'Set the bar property',\n                'longDescription'  => null,\n                'tags'             => [\n                    new Tag\\ParamTag([\n                        'paramName' => 'bar',\n                        'datatype'  => 'string'\n                    ]),\n                    new Tag\\ReturnTag([\n                        'datatype'  => 'string',\n                    ]),\n                ],\n            ]),\n        ]),\n        // Method passed as concrete instance\n        new MethodGenerator(\n            'getBar',\n            [],\n            MethodGenerator::FLAG_PUBLIC,\n            'return $this->_bar;',\n            DocBlockGenerator::fromArray([\n                'shortDescription' => 'Retrieve the bar property',\n                'longDescription'  => null,\n                'tags'             => [\n                    new Tag\\ReturnTag([\n                        'datatype'  => 'string|null',\n                    ]),\n                ],\n            ])\n        ),\n    ]);\n\necho $foo->generate();  The above generates the following output:  /**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n    /**\n     * Set the bar property\n     *\n     * @param string bar\n     * @return string\n     */\n    public function setBar($bar)\n    {\n        $this->_bar = $bar;\n        return $this;\n    }\n\n    /**\n     * Retrieve the bar property\n     *\n     * @return string|null\n     */\n    public function getBar()\n    {\n        return $this->_bar;\n    }\n\n}",
            "title": "Generating PHP classes with class methods"
        },
        {
            "location": "/generator/examples/#generating-php-files",
            "text": "Zend\\Code\\Generator\\FileGenerator  can be used to generate the contents of a  PHP  file. You can\ninclude classes as well as arbitrary content body. When attaching classes, you should attach either\nconcrete  Zend\\Code\\Generator\\ClassGenerator  instances or an array defining the class.  In the example below, we will assume you've defined  $foo  per one of the class definitions in a\nprevious example.  use Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\FileGenerator;\n\n$file = FileGenerator::fromArray([\n    'classes'  => [$foo],\n    'docblock' => DocBlockGenerator::fromArray([\n        'shortDescription' => 'Foo class file',\n        'longDescription'   => null,\n        'tags'             => [\n            [\n                'name'        => 'license',\n                'description' => 'New BSD',\n            ],\n        ],\n    ]),\n    'body'     => 'define(\\'APPLICATION_ENV\\', \\'testing\\');',\n]);  Calling  generate()  will generate the code -- but not write it to a file. You will need to capture\nthe contents and write them to a file yourself. As an example:  $code = $file->generate();\nfile_put_contents('Foo.php', $code);  The above will generate the following file:  <?php\n/**\n * Foo class file\n *\n * @license New BSD\n */\n\n/**\n * Sample generated class\n *\n * This is a class generated with Zend\\Code\\Generator.\n *\n * @version $Rev:$\n * @license New BSD\n */\nclass Foo\n{\n\n    protected $_bar = 'baz';\n\n    public $baz = 'bat';\n\n    const bat = 'foobarbazbat';\n\n    /**\n     * Set the bar property\n     *\n     * @param string bar\n     * @return string\n     */\n    public function setBar($bar)\n    {\n        $this->_bar = $bar;\n        return $this;\n    }\n\n    /**\n     * Retrieve the bar property\n     *\n     * @return string|null\n     */\n    public function getBar()\n    {\n        return $this->_bar;\n    }\n\n}\n\ndefine('APPLICATION_ENV', 'testing');",
            "title": "Generating PHP files"
        },
        {
            "location": "/generator/examples/#add-code-to-existing-php-files-and-classes",
            "text": "",
            "title": "Add code to existing PHP files and classes"
        },
        {
            "location": "/generator/examples/#seeding-php-file-code-generation-via-reflection",
            "text": "You can add  PHP  code to an existing  PHP  file using the code generator. To do so, you need to\nfirst do reflection on it. The static method  fromReflectedFileName()  allows you to do this.  $generator = Zend\\Code\\Generator\\FileGenerator::fromReflectedFileName($path);   \n$generator->setBody(\"\\$foo->bar();\");\nfile_put_contents($path, $generator->generate());",
            "title": "Seeding PHP file code generation via reflection"
        },
        {
            "location": "/generator/examples/#seeding-php-class-generation-via-reflection",
            "text": "You may add code to an existing class. To do so, first use the static  fromReflection()  method to\nmap the class into a generator object. From there, you may add additional properties or methods, and\nthen regenerate the class.  use Zend\\Code\\Generator\\ClassGenerator;\nuse Zend\\Code\\Generator\\DocBlockGenerator;\nuse Zend\\Code\\Generator\\DocBlock\\Tag;\nuse Zend\\Code\\Generator\\MethodGenerator;\nuse Zend\\Code\\Reflection\\ClassReflection;\n\n$generator = ClassGenerator::fromReflection(\n    new ClassReflection($class)\n);\n$generator->addMethod(\n    'setBaz',\n    ['baz'],\n    MethodGenerator::FLAG_PUBLIC,\n    '$this->_baz = $baz;' . \"\\n\" . 'return $this;',\n    DocBlockGenerator::fromArray([\n        'shortDescription' => 'Set the baz property',\n        'longDescription'  => null,\n        'tags'             => [\n            new Tag\\ParamTag([\n                'paramName' => 'baz',\n                'datatype'  => 'string'\n            ]),\n            new Tag\\ReturnTag([\n                'datatype'  => 'string',\n            ]),\n        ],\n    ])\n);\n$code = $generator->generate();",
            "title": "Seeding PHP class generation via reflection"
        },
        {
            "location": "/generator/reference/",
            "text": "Zend\\Code\\Generator Reference\n\n\nAbstract Classes and Interfaces\n\n\nZend\\Code\\Generator\\GeneratorInterface\n\n\nThe base interface from which all CodeGenerator classes implement provides the minimal functionality\nnecessary. It's \nAPI\n is as follows:\n\n\ninterface Zend\\Code\\Generator\\GeneratorInterface\n{\n    public function generate();\n}\n\n\n\nZend\\Code\\Generator\\AbstractGenerator\n\n\nZend\\Code\\Generator\\AbstractGenerator\n implements \nZend\\Code\\Generator\\GeneratorInterface\n, and\nadds some properties for tracking whether content has changed as well as the amount of indentation\nthat should appear before generated content. Its \nAPI\n is as follows:\n\n\nabstract class Zend\\Code\\Generator\\AbstractGenerator\n    implements Zend\\Code\\Generator\\GeneratorInterface\n{\n    public function __construct(Array|Traversable $options = [])\n    public function setOptions(Array $options)\n    public function setSourceContent($sourceContent)\n    public function getSourceContent()\n    public function setSourceDirty($isSourceDirty = true)\n    public function isSourceDirty()\n    public function setIndentation($indentation)\n    public function getIndentation()\n}\n\n\n\nThe constructor passes the \n$options\n parameter to \nsetOptions()\n.\n\n\nLike most classes in Zend Framework, \nsetOptions()\n compares an option key to existing setters in\nthe class, and passes the value on to that method if found.\n\n\nsetSourceContent()\n and \ngetSourceContent()\n are intended to either set the default content for the\ncode being generated, or to replace said content once all generation tasks are complete.\n\n\nZend\\Code\\Generator\\AbstractMemberGenerator\n\n\nZend\\Code\\Generator\\AbstractMemberGenerator\n is a base class for generating class members --\nproperties and methods -- and provides accessors and mutators for establishing visibility; whether\nor not the member is abstract, static, or final; and the name of the member. Its \nAPI\n is as\nfollows:\n\n\nabstract class Zend\\Code\\Generator\\AbstractMemberGenerator\n    extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public function setAbstract($isAbstract)\n    public function isAbstract()\n    public function setStatic($isStatic)\n    public function isStatic()\n    public function setVisibility($visibility)\n    public function getVisibility()\n    public function setName($name)\n    public function getName()\n}\n\n\n\nConcrete CodeGenerator Classes\n\n\nZend\\Code\\Generator\\BodyGenerator\n\n\nZend\\Code\\Generator\\BodyGenerator\n is intended for generating arbitrary procedural code to include\nwithin a file. As such, you simply set content for the object, and it will return that content when\nyou invoke \ngenerate()\n.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\BodyGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public function setContent($content)\n    public function getContent()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\ClassGenerator\n\n\nZend\\Code\\Generator\\ClassGenerator\n is intended for generating \nPHP\n classes. The basic\nfunctionality just generates the \nPHP\n class itself, as well as optionally the related \nPHP\n\nDocBlock. Classes may implement or inherit from other classes, and may be marked as abstract.\nUtilizing other code generator classes, you can also attach class constants, properties, and\nmethods.\n\n\nThe \nAPI\n is as follows:\n\n\nclass Zend\\Code\\Generator\\ClassGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\ClassReflection $reflectionClass\n    )\n    public function addConstants(Array $properties)\n    public function addConstant($property)\n    public function getConstants()\n    public function getConstant($propertyName)       \n    public function removeConstant($constantName)       \n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setName($name)\n    public function getName()\n    public function setAbstract($isAbstract)\n    public function isAbstract()\n    public function setExtendedClass($extendedClass)\n    public function getExtendedClass()\n    public function hasExtentedClass()\n    public function removeExtentedClass()\n    public function setImplementedInterfaces(Array $implementedInterfaces)\n    public function getImplementedInterfaces()\n    public function addProperties(Array $properties)\n    public function addProperty($property)\n    public function getProperties()\n    public function getProperty($propertyName)\n    public function removeProperty($propertyName)\n    public function addMethods(Array $methods)\n    public function addMethod(\n        $name,\n        Array $parameters = [],\n        $flags = Zend\\Code\\Generator\\MethodGenerator::FLAG_PUBLIC,\n        $body = null,\n        $docBlock = null\n    )\n    public function getMethods()\n    public function getMethod($methodName)\n    public function hasMethod($methodName)\n    public function hasUse($use)\n    public function removeUse($use)\n    public function hasUseAlias($use)\n    public function removeUseAlias($use)\n    public function hasImplementedInterface($implementedInterface)\n    public function removeImplementedInterface($implementedInterface)\n    public function isSourceDirty()\n    public function generate()\n}\n\n\n\nThe \naddProperty()\n method accepts an array of information that may be used to generate a\n\nZend\\Code\\Generator\\PropertyGenerator\n instance -- or simply an instance of\n\nZend\\Code\\Generator\\PropertyGenerator\n. Likewise, \naddMethod()\n accepts either an array of\ninformation for generating a \nZend\\Code\\Generator\\MethodGenerator\n instance or a concrete instance\nof that class.\n\n\nNote that \nsetDocBlock()\n expects an instance of \nZend\\Code\\Generator\\DocBlockGenerator\n.\n\n\nZend\\Code\\Generator\\DocBlockGenerator\n\n\nZend\\Code\\Generator\\DocBlockGenerator\n can be used to generate arbitrary \nPHP\n docblocks, including\nall the standard docblock features: short and long descriptions and annotation tags.\n\n\nAnnotation tags may be set using the \nsetTag()\n and \nsetTags()\n methods; these each take either an\narray describing the tag that may be passed to the \nZend\\Code\\Generator\\DocBlock\\Tag\n constructor,\nor an instance of that class.\n\n\nThe \nAPI\n is as follows:\n\n\nclass Zend\\Code\\Generator\\DocBlockGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocblockReflection $reflectionDocblock\n    )\n    public function setShortDescription($shortDescription)\n    public function getShortDescription()\n    public function setLongDescription($longDescription)\n    public function getLongDescription()\n    public function setTags(Array $tags)\n    public function setTag($tag)\n    public function getTags()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\DocBlock\\Tag\n\n\nZend\\Code\\Generator\\DocBlock\\Tag\n is intended for creating arbitrary annotation tags for inclusion\nin \nPHP\n docblocks. Tags are expected to contain a name (the portion immediately following the '@'\nsymbol) and a description (everything following the tag name).\n\n\nThe class \nAPI\n is as follows:\n\n\nclass Zend\\Code\\Generator\\DocBlock\\Tag\n    extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTag\n    )\n    public function setName($name)\n    public function getName()\n    public function setDescription($description)\n    public function getDescription()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n\n\nZend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n is a specialized version of\n\nZend\\Code\\Generator\\DocBlock\\Tag\n, and represents a method parameter. The tag name is therefor\nknown (\"param\"), but due to the format of this annotation tag, additional information is required in\norder to generate it: the parameter name and data type it represents.\n\n\nThe class \nAPI\n is as follows:\n\n\nclass Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n    extends Zend\\Code\\Generator\\DocBlock\\Tag\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagParam\n    )\n    public function setDatatype($datatype)\n    public function getDatatype()\n    public function setParamName($paramName)\n    public function getParamName()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\DocBlock\\Tag\\ReturnTag\n\n\nLike the param docblock tag variant, \nZend\\Code\\Generator\\DocBlock\\Tag\\ReturnTag\n is an annotation\ntag variant for representing a method return value. In this case, the annotation tag name is known\n(\"return\"), but requires a return type.\n\n\nThe class \nAPI\n is as follows:\n\n\nclass Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n    extends Zend\\Code\\Generator\\DocBlock\\Tag\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagReturn\n    )\n    public function setDatatype($datatype)\n    public function getDatatype()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\FileGenerator\n\n\nZend\\Code\\Generator\\FileGenerator\n is used to generate the full contents of a file that will\ncontain \nPHP\n code. The file may contain classes or arbitrary \nPHP\n code, as well as a file-level\ndocblock if desired.\n\n\nWhen adding classes to the file, you will need to pass either an array of information to pass to the\n\nZend\\Code\\Generator\\ClassGenerator\n constructor, or an instance of that class. Similarly, with\ndocblocks, you will need to pass information for the \nZend\\Code\\Generator\\DocBlockGenerator\n\nconstructor to consume or an instance of the class.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\FileGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflectedFilePath(\n        $filePath,\n        $usePreviousCodeGeneratorIfItExists = true,\n        $includeIfNotAlreadyIncluded = true)\n    public static function fromReflection(Zend\\Code\\Reflection\\FileReflection $reflectionFile)\n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setRequiredFiles($requiredFiles)\n    public function getRequiredFiles()\n    public function setClasses(Array $classes)\n    public function getClass($name = null)\n    public function setClass($class)\n    public function setFilename($filename)\n    public function getFilename()\n    public function getClasses()\n    public function setBody($body)\n    public function getBody()\n    public function isSourceDirty()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\Member\\ContainerGenerator\n\n\nZend\\Code\\Generator\\Member\\ContainerGenerator\n is used internally by\n\nZend\\Code\\Generator\\ClassGenerator\n to keep track of class members -- properties and methods alike.\nThese are indexed by name, using the concrete instances of the members as values.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\Member\\ContainerGenerator extends ArrayObject\n{\n    public function __construct($type = self::TYPE_PROPERTY)\n}\n\n\n\nZend\\Code\\Generator\\MethodGenerator\n\n\nZend\\Code\\Generator\\MethodGenerator\n describes a class method, and can generate both the code and\nthe docblock for the method. The visibility and status as static, abstract, or final may be\nindicated, per its parent class, \nZend\\Code\\Generator\\AbstractMemberGenerator\n. Finally, the\nparameters and return value for the method may be specified.\n\n\nParameters may be set using \nsetParameter()\n or \nsetParameters()\n. In each case, a parameter should\neither be an array of information to pass to the \nZend\\Code\\Generator\\ParameterGenerator\n\nconstructor or an instance of that class.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\MethodGenerator\n    extends Zend\\Code\\Generator\\AbstractMemberGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\MethodReflection $reflectionMethod\n    )\n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setFinal($isFinal)\n    public function setParameters(Array $parameters)\n    public function setParameter($parameter)\n    public function getParameters()\n    public function setBody($body)\n    public function getBody()\n    public function generate()\n}\n\n\n\nZend\\Code\\Generator\\ParameterGenerator\n\n\nZend\\Code\\Generator\\ParameterGenerator\n may be used to specify method parameters. Each parameter\nmay have a position (if unspecified, the order in which they are registered with the method will be\nused), a default value, and a data type; a parameter name is required.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\ParameterGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\ParameterReflection $reflectionParameter\n    )\n    public function setType($type)\n    public function getType()\n    public function setName($name)\n    public function getName()\n    public function setDefaultValue($defaultValue)\n    public function getDefaultValue()\n    public function setPosition($position)\n    public function getPosition()\n    public function getPassedByReference()\n    public function setPassedByReference($passedByReference)\n    public function generate()\n}\n\n\n\nThere are several problems that might occur when trying to set \nNULL\n, booleans or arrays as default\nvalues. For this the value holder object \nZend\\Code\\Generator\\ParameterDefaultValueGenerator\n can be\nused, for example:\n\n\n$parameter = new Zend\\Code\\Generator\\ParameterGenerator();\n$parameter->setDefaultValue(\n    new Zend\\Code\\Generator\\ValueGenerator(\"null\")\n);\n$parameter->setDefaultValue(\n    new Zend\\Code\\Generator\\ValueGenerator(\"['foo', 'bar']\")\n);\n\n\n\nInternally \nsetDefaultValue()\n also converts the values which can't be expressed in \nPHP\n into the\nvalue holder.\n\n\nZend\\Code\\Generator\\PropertyGenerator\n\n\nZend\\Code\\Generator\\PropertyGenerator\n describes a class property, which may be either a constant\nor a variable. In each case, the property may have an optional default value associated with it.\nAdditionally, the visibility of variable properties may be set, per the parent class,\n\nZend\\Code\\Generator\\AbstractMemberGenerator\n.\n\n\nThe \nAPI\n of the class is as follows:\n\n\nclass Zend\\Code\\Generator\\PropertyGenerator\n    extends Zend\\Code\\Generator\\AbstractMemberGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\PropertyReflection $reflectionProperty\n    )\n    public function setConst($const)\n    public function isConst()\n    public function setDefaultValue($defaultValue)\n    public function getDefaultValue()\n    public function generate()\n}",
            "title": "Reference"
        },
        {
            "location": "/generator/reference/#zend92code92generator-reference",
            "text": "",
            "title": "Zend\\Code\\Generator Reference"
        },
        {
            "location": "/generator/reference/#abstract-classes-and-interfaces",
            "text": "",
            "title": "Abstract Classes and Interfaces"
        },
        {
            "location": "/generator/reference/#zend92code92generator92generatorinterface",
            "text": "The base interface from which all CodeGenerator classes implement provides the minimal functionality\nnecessary. It's  API  is as follows:  interface Zend\\Code\\Generator\\GeneratorInterface\n{\n    public function generate();\n}",
            "title": "Zend\\Code\\Generator\\GeneratorInterface"
        },
        {
            "location": "/generator/reference/#zend92code92generator92abstractgenerator",
            "text": "Zend\\Code\\Generator\\AbstractGenerator  implements  Zend\\Code\\Generator\\GeneratorInterface , and\nadds some properties for tracking whether content has changed as well as the amount of indentation\nthat should appear before generated content. Its  API  is as follows:  abstract class Zend\\Code\\Generator\\AbstractGenerator\n    implements Zend\\Code\\Generator\\GeneratorInterface\n{\n    public function __construct(Array|Traversable $options = [])\n    public function setOptions(Array $options)\n    public function setSourceContent($sourceContent)\n    public function getSourceContent()\n    public function setSourceDirty($isSourceDirty = true)\n    public function isSourceDirty()\n    public function setIndentation($indentation)\n    public function getIndentation()\n}  The constructor passes the  $options  parameter to  setOptions() .  Like most classes in Zend Framework,  setOptions()  compares an option key to existing setters in\nthe class, and passes the value on to that method if found.  setSourceContent()  and  getSourceContent()  are intended to either set the default content for the\ncode being generated, or to replace said content once all generation tasks are complete.",
            "title": "Zend\\Code\\Generator\\AbstractGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92abstractmembergenerator",
            "text": "Zend\\Code\\Generator\\AbstractMemberGenerator  is a base class for generating class members --\nproperties and methods -- and provides accessors and mutators for establishing visibility; whether\nor not the member is abstract, static, or final; and the name of the member. Its  API  is as\nfollows:  abstract class Zend\\Code\\Generator\\AbstractMemberGenerator\n    extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public function setAbstract($isAbstract)\n    public function isAbstract()\n    public function setStatic($isStatic)\n    public function isStatic()\n    public function setVisibility($visibility)\n    public function getVisibility()\n    public function setName($name)\n    public function getName()\n}",
            "title": "Zend\\Code\\Generator\\AbstractMemberGenerator"
        },
        {
            "location": "/generator/reference/#concrete-codegenerator-classes",
            "text": "",
            "title": "Concrete CodeGenerator Classes"
        },
        {
            "location": "/generator/reference/#zend92code92generator92bodygenerator",
            "text": "Zend\\Code\\Generator\\BodyGenerator  is intended for generating arbitrary procedural code to include\nwithin a file. As such, you simply set content for the object, and it will return that content when\nyou invoke  generate() .  The  API  of the class is as follows:  class Zend\\Code\\Generator\\BodyGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public function setContent($content)\n    public function getContent()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\BodyGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92classgenerator",
            "text": "Zend\\Code\\Generator\\ClassGenerator  is intended for generating  PHP  classes. The basic\nfunctionality just generates the  PHP  class itself, as well as optionally the related  PHP \nDocBlock. Classes may implement or inherit from other classes, and may be marked as abstract.\nUtilizing other code generator classes, you can also attach class constants, properties, and\nmethods.  The  API  is as follows:  class Zend\\Code\\Generator\\ClassGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\ClassReflection $reflectionClass\n    )\n    public function addConstants(Array $properties)\n    public function addConstant($property)\n    public function getConstants()\n    public function getConstant($propertyName)       \n    public function removeConstant($constantName)       \n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setName($name)\n    public function getName()\n    public function setAbstract($isAbstract)\n    public function isAbstract()\n    public function setExtendedClass($extendedClass)\n    public function getExtendedClass()\n    public function hasExtentedClass()\n    public function removeExtentedClass()\n    public function setImplementedInterfaces(Array $implementedInterfaces)\n    public function getImplementedInterfaces()\n    public function addProperties(Array $properties)\n    public function addProperty($property)\n    public function getProperties()\n    public function getProperty($propertyName)\n    public function removeProperty($propertyName)\n    public function addMethods(Array $methods)\n    public function addMethod(\n        $name,\n        Array $parameters = [],\n        $flags = Zend\\Code\\Generator\\MethodGenerator::FLAG_PUBLIC,\n        $body = null,\n        $docBlock = null\n    )\n    public function getMethods()\n    public function getMethod($methodName)\n    public function hasMethod($methodName)\n    public function hasUse($use)\n    public function removeUse($use)\n    public function hasUseAlias($use)\n    public function removeUseAlias($use)\n    public function hasImplementedInterface($implementedInterface)\n    public function removeImplementedInterface($implementedInterface)\n    public function isSourceDirty()\n    public function generate()\n}  The  addProperty()  method accepts an array of information that may be used to generate a Zend\\Code\\Generator\\PropertyGenerator  instance -- or simply an instance of Zend\\Code\\Generator\\PropertyGenerator . Likewise,  addMethod()  accepts either an array of\ninformation for generating a  Zend\\Code\\Generator\\MethodGenerator  instance or a concrete instance\nof that class.  Note that  setDocBlock()  expects an instance of  Zend\\Code\\Generator\\DocBlockGenerator .",
            "title": "Zend\\Code\\Generator\\ClassGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92docblockgenerator",
            "text": "Zend\\Code\\Generator\\DocBlockGenerator  can be used to generate arbitrary  PHP  docblocks, including\nall the standard docblock features: short and long descriptions and annotation tags.  Annotation tags may be set using the  setTag()  and  setTags()  methods; these each take either an\narray describing the tag that may be passed to the  Zend\\Code\\Generator\\DocBlock\\Tag  constructor,\nor an instance of that class.  The  API  is as follows:  class Zend\\Code\\Generator\\DocBlockGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocblockReflection $reflectionDocblock\n    )\n    public function setShortDescription($shortDescription)\n    public function getShortDescription()\n    public function setLongDescription($longDescription)\n    public function getLongDescription()\n    public function setTags(Array $tags)\n    public function setTag($tag)\n    public function getTags()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\DocBlockGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92docblock92tag",
            "text": "Zend\\Code\\Generator\\DocBlock\\Tag  is intended for creating arbitrary annotation tags for inclusion\nin  PHP  docblocks. Tags are expected to contain a name (the portion immediately following the '@'\nsymbol) and a description (everything following the tag name).  The class  API  is as follows:  class Zend\\Code\\Generator\\DocBlock\\Tag\n    extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTag\n    )\n    public function setName($name)\n    public function getName()\n    public function setDescription($description)\n    public function getDescription()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\DocBlock\\Tag"
        },
        {
            "location": "/generator/reference/#zend92code92generator92docblock92tag92paramtag",
            "text": "Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag  is a specialized version of Zend\\Code\\Generator\\DocBlock\\Tag , and represents a method parameter. The tag name is therefor\nknown (\"param\"), but due to the format of this annotation tag, additional information is required in\norder to generate it: the parameter name and data type it represents.  The class  API  is as follows:  class Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n    extends Zend\\Code\\Generator\\DocBlock\\Tag\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagParam\n    )\n    public function setDatatype($datatype)\n    public function getDatatype()\n    public function setParamName($paramName)\n    public function getParamName()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag"
        },
        {
            "location": "/generator/reference/#zend92code92generator92docblock92tag92returntag",
            "text": "Like the param docblock tag variant,  Zend\\Code\\Generator\\DocBlock\\Tag\\ReturnTag  is an annotation\ntag variant for representing a method return value. In this case, the annotation tag name is known\n(\"return\"), but requires a return type.  The class  API  is as follows:  class Zend\\Code\\Generator\\DocBlock\\Tag\\ParamTag\n    extends Zend\\Code\\Generator\\DocBlock\\Tag\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagReturn\n    )\n    public function setDatatype($datatype)\n    public function getDatatype()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\DocBlock\\Tag\\ReturnTag"
        },
        {
            "location": "/generator/reference/#zend92code92generator92filegenerator",
            "text": "Zend\\Code\\Generator\\FileGenerator  is used to generate the full contents of a file that will\ncontain  PHP  code. The file may contain classes or arbitrary  PHP  code, as well as a file-level\ndocblock if desired.  When adding classes to the file, you will need to pass either an array of information to pass to the Zend\\Code\\Generator\\ClassGenerator  constructor, or an instance of that class. Similarly, with\ndocblocks, you will need to pass information for the  Zend\\Code\\Generator\\DocBlockGenerator \nconstructor to consume or an instance of the class.  The  API  of the class is as follows:  class Zend\\Code\\Generator\\FileGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflectedFilePath(\n        $filePath,\n        $usePreviousCodeGeneratorIfItExists = true,\n        $includeIfNotAlreadyIncluded = true)\n    public static function fromReflection(Zend\\Code\\Reflection\\FileReflection $reflectionFile)\n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setRequiredFiles($requiredFiles)\n    public function getRequiredFiles()\n    public function setClasses(Array $classes)\n    public function getClass($name = null)\n    public function setClass($class)\n    public function setFilename($filename)\n    public function getFilename()\n    public function getClasses()\n    public function setBody($body)\n    public function getBody()\n    public function isSourceDirty()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\FileGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92member92containergenerator",
            "text": "Zend\\Code\\Generator\\Member\\ContainerGenerator  is used internally by Zend\\Code\\Generator\\ClassGenerator  to keep track of class members -- properties and methods alike.\nThese are indexed by name, using the concrete instances of the members as values.  The  API  of the class is as follows:  class Zend\\Code\\Generator\\Member\\ContainerGenerator extends ArrayObject\n{\n    public function __construct($type = self::TYPE_PROPERTY)\n}",
            "title": "Zend\\Code\\Generator\\Member\\ContainerGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92methodgenerator",
            "text": "Zend\\Code\\Generator\\MethodGenerator  describes a class method, and can generate both the code and\nthe docblock for the method. The visibility and status as static, abstract, or final may be\nindicated, per its parent class,  Zend\\Code\\Generator\\AbstractMemberGenerator . Finally, the\nparameters and return value for the method may be specified.  Parameters may be set using  setParameter()  or  setParameters() . In each case, a parameter should\neither be an array of information to pass to the  Zend\\Code\\Generator\\ParameterGenerator \nconstructor or an instance of that class.  The  API  of the class is as follows:  class Zend\\Code\\Generator\\MethodGenerator\n    extends Zend\\Code\\Generator\\AbstractMemberGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\MethodReflection $reflectionMethod\n    )\n    public function setDocblock(Zend\\Code\\Generator\\DocBlockGenerator $docblock)\n    public function getDocblock()\n    public function setFinal($isFinal)\n    public function setParameters(Array $parameters)\n    public function setParameter($parameter)\n    public function getParameters()\n    public function setBody($body)\n    public function getBody()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\MethodGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92parametergenerator",
            "text": "Zend\\Code\\Generator\\ParameterGenerator  may be used to specify method parameters. Each parameter\nmay have a position (if unspecified, the order in which they are registered with the method will be\nused), a default value, and a data type; a parameter name is required.  The  API  of the class is as follows:  class Zend\\Code\\Generator\\ParameterGenerator extends Zend\\Code\\Generator\\AbstractGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\ParameterReflection $reflectionParameter\n    )\n    public function setType($type)\n    public function getType()\n    public function setName($name)\n    public function getName()\n    public function setDefaultValue($defaultValue)\n    public function getDefaultValue()\n    public function setPosition($position)\n    public function getPosition()\n    public function getPassedByReference()\n    public function setPassedByReference($passedByReference)\n    public function generate()\n}  There are several problems that might occur when trying to set  NULL , booleans or arrays as default\nvalues. For this the value holder object  Zend\\Code\\Generator\\ParameterDefaultValueGenerator  can be\nused, for example:  $parameter = new Zend\\Code\\Generator\\ParameterGenerator();\n$parameter->setDefaultValue(\n    new Zend\\Code\\Generator\\ValueGenerator(\"null\")\n);\n$parameter->setDefaultValue(\n    new Zend\\Code\\Generator\\ValueGenerator(\"['foo', 'bar']\")\n);  Internally  setDefaultValue()  also converts the values which can't be expressed in  PHP  into the\nvalue holder.",
            "title": "Zend\\Code\\Generator\\ParameterGenerator"
        },
        {
            "location": "/generator/reference/#zend92code92generator92propertygenerator",
            "text": "Zend\\Code\\Generator\\PropertyGenerator  describes a class property, which may be either a constant\nor a variable. In each case, the property may have an optional default value associated with it.\nAdditionally, the visibility of variable properties may be set, per the parent class, Zend\\Code\\Generator\\AbstractMemberGenerator .  The  API  of the class is as follows:  class Zend\\Code\\Generator\\PropertyGenerator\n    extends Zend\\Code\\Generator\\AbstractMemberGenerator\n{\n    public static function fromReflection(\n        Zend\\Code\\Reflection\\PropertyReflection $reflectionProperty\n    )\n    public function setConst($const)\n    public function isConst()\n    public function setDefaultValue($defaultValue)\n    public function getDefaultValue()\n    public function generate()\n}",
            "title": "Zend\\Code\\Generator\\PropertyGenerator"
        },
        {
            "location": "/migration/",
            "text": "Migrating from zend-code v2 to v3\n\n\nstring\n, \nint\n, \nfloat\n, \nbool\n are no longer ignored\n\n\nIn 2.x, a \nZend\\Code\\Generator\\ParameterGenerator\n with name \nfoo\n and type \n\nstring\n, \nint\n, \nfloat\n or \nbool\n simply generated code \n\"$foo\"\n:\n\n\n$generator = new \\Zend\\Code\\ParameterGenerator('foo');\n\n$generator->setType('string');\n\necho $generator->generate(); // \"$foo\"\n\n\n\nIn 3.x, this code will instead produce \n\"string $foo\"\n.\nIf you generate code that should run in PHP 5.x, it is advisable to strip\n\nstring\n, \nint\n, \nfloat\n and \nbool\n from type definitions passed to\n\nZend\\Code\\ParameterGenerator\n instances. The quickest way is to set the \ntype to \nnull\n, if it matches any of these scalar types:\n\n\nif (in_array($type, ['string', 'int', 'float', 'bool'])) {\n    $type = null;\n}\n\n$generator->setType($type);\n\n\n\nParameterReflection::getType()\n changes\n\n\nPHP 7 introduced \nReflectionParameter#getType()\n.\n\n\nIn order to not override this method, \nZend\\Code\\Reflection\\ParameterReflection#getType()\n\nwas renamed to \nZend\\Code\\Reflection\\ParameterReflection#detectType()\n.\n\n\nIf you relied on \nZend\\Code\\Reflection\\ParameterReflection#getType()\n, you can\nsimply replace the method calls in your code.\n\n\nDocBlock types ignored by \nParameterGenerator::fromReflection()\n\n\nAs a direct consequence of the previous change, calls to \n\nZend\\Code\\Generator\\ParameterGenerator::fromReflection()\n will not mirror the\ntype hints read from a method's DocBlock.\n\n\nAs an example, take following code:\n\n\nclass Foo\n{\n    /**\n     * @param string $baz\n     */\n    public function bar($baz)\n    {\n    }\n}\n\n$methodGenerator = \\Zend\\Code\\Generator\\MethodGenerator::fromReflection(\n    new \\Zend\\Code\\Reflection\\MethodReflection('Foo', 'bar')\n);\n\nvar_dump($methodGenerator->getParameters()[0]->getType());\n\n\n\nIn version 2.x, this code produces \n\"string\"\n, in version 3.x it returns \nnull\n. If you \nneed to rely on the types in the annotations, please use\n\nZend\\Code\\Reflection\\ParameterReflection#detectType()\n instead, and build a\n\nMethodGenerator\n instance manually.\n\n\nThis change is required: since signatures in PHP 7 include scalar type hints.\nThat also means that reflecting scalar type hints from DocBlocks into the\nsignature of a generated method may lead to fatal errors (due to signature\nmismatch) at runtime.\n\n\nType strings are validated\n\n\nIf you attempt to generate type-hints for parameters or return types, those types are\nnow validated before the code is generated.\n\n\nBe sure to check which values you pass to \nZend\\Code\\Generator\\MethodGenerator#setReturnType()\n\nor \nZend\\Code\\Generator\\ParameterGenerator#setType()\n, as you may incur in a\n\nZend\\Code\\Generator\\Exception\\InvalidArgumentException\n being thrown if any\nof those types are invalid strings:\n\n\n$parameterGenerator->setType('foo'); // valid\n$parameterGenerator->setType('array'); // valid\n$parameterGenerator->setType('bool'); // valid\n$parameterGenerator->setType('123'); // invalid (throws exception)\n$parameterGenerator->setType(''); // invalid (throws exception)\n$parameterGenerator->setType('*'); // invalid (throws exception)\n$parameterGenerator->setType('\\\\'); // invalid (throws exception)\n\n\n\nGenerated type-hints are now prefixed by \n\"\\\"\n\n\nGenerated type-hints are now prefixed with the \nNAMESPACE_SEPARATOR\n,\n\n\"\\\"\n.\n\n\nTake following example code:\n\n\n$parameter = new \\Zend\\Code\\Generator\\ParameterGenerator('bar', 'baz');\n$method    = new \\Zend\\Code\\Generator\\MethodGenerator('foo', [$parameter]);\n\n$method->setReturnType('tab');\n\necho $method->generate();\n\n\n\nThis code produces \npublic function foo(baz $bar) {}\n in 2.x.\nIn version 3.x, it produces \npublic function foo(\\baz $bar) : \\tab {}\n.\n\n\nIn order to avoid migration problems, be sure to always pass fully qualified class\nnames to \nZend\\Code\\Generator\\MethodGenerator\n and \nZend\\Code\\Generator\\ParameterGenerator\n.\n\n\nParameterGenerator::$simple\n was removed\n\n\nIf you extended \nZend\\Code\\Generator\\ParameterGenerator\n, be sure to check if you\nare accessing the protected static variable \n$simple\n: it was removed, and you should\nadapt your code by either copying it into your class or avoiding its usage.\n\n\nParameterGenerator::$type\n has changed\n\n\nIf you extended \nZend\\Code\\Generator\\ParameterGenerator\n, be sure to check if you\nare accessing the protected variable \n$type\n: its type has changed.\nWhile it can still be used as a string via an explicit \n(string)\n cast, the type of\nthis protected member is now \nnull|Zend\\Code\\Generator\\TypeGenerator\n.",
            "title": "Migration"
        },
        {
            "location": "/migration/#migrating-from-zend-code-v2-to-v3",
            "text": "",
            "title": "Migrating from zend-code v2 to v3"
        },
        {
            "location": "/migration/#string-int-float-bool-are-no-longer-ignored",
            "text": "In 2.x, a  Zend\\Code\\Generator\\ParameterGenerator  with name  foo  and type  string ,  int ,  float  or  bool  simply generated code  \"$foo\" :  $generator = new \\Zend\\Code\\ParameterGenerator('foo');\n\n$generator->setType('string');\n\necho $generator->generate(); // \"$foo\"  In 3.x, this code will instead produce  \"string $foo\" .\nIf you generate code that should run in PHP 5.x, it is advisable to strip string ,  int ,  float  and  bool  from type definitions passed to Zend\\Code\\ParameterGenerator  instances. The quickest way is to set the \ntype to  null , if it matches any of these scalar types:  if (in_array($type, ['string', 'int', 'float', 'bool'])) {\n    $type = null;\n}\n\n$generator->setType($type);",
            "title": "string, int, float, bool are no longer ignored"
        },
        {
            "location": "/migration/#parameterreflectiongettype-changes",
            "text": "PHP 7 introduced  ReflectionParameter#getType() .  In order to not override this method,  Zend\\Code\\Reflection\\ParameterReflection#getType() \nwas renamed to  Zend\\Code\\Reflection\\ParameterReflection#detectType() .  If you relied on  Zend\\Code\\Reflection\\ParameterReflection#getType() , you can\nsimply replace the method calls in your code.",
            "title": "ParameterReflection::getType() changes"
        },
        {
            "location": "/migration/#docblock-types-ignored-by-parametergeneratorfromreflection",
            "text": "As a direct consequence of the previous change, calls to  Zend\\Code\\Generator\\ParameterGenerator::fromReflection()  will not mirror the\ntype hints read from a method's DocBlock.  As an example, take following code:  class Foo\n{\n    /**\n     * @param string $baz\n     */\n    public function bar($baz)\n    {\n    }\n}\n\n$methodGenerator = \\Zend\\Code\\Generator\\MethodGenerator::fromReflection(\n    new \\Zend\\Code\\Reflection\\MethodReflection('Foo', 'bar')\n);\n\nvar_dump($methodGenerator->getParameters()[0]->getType());  In version 2.x, this code produces  \"string\" , in version 3.x it returns  null . If you \nneed to rely on the types in the annotations, please use Zend\\Code\\Reflection\\ParameterReflection#detectType()  instead, and build a MethodGenerator  instance manually.  This change is required: since signatures in PHP 7 include scalar type hints.\nThat also means that reflecting scalar type hints from DocBlocks into the\nsignature of a generated method may lead to fatal errors (due to signature\nmismatch) at runtime.",
            "title": "DocBlock types ignored by ParameterGenerator::fromReflection()"
        },
        {
            "location": "/migration/#type-strings-are-validated",
            "text": "If you attempt to generate type-hints for parameters or return types, those types are\nnow validated before the code is generated.  Be sure to check which values you pass to  Zend\\Code\\Generator\\MethodGenerator#setReturnType() \nor  Zend\\Code\\Generator\\ParameterGenerator#setType() , as you may incur in a Zend\\Code\\Generator\\Exception\\InvalidArgumentException  being thrown if any\nof those types are invalid strings:  $parameterGenerator->setType('foo'); // valid\n$parameterGenerator->setType('array'); // valid\n$parameterGenerator->setType('bool'); // valid\n$parameterGenerator->setType('123'); // invalid (throws exception)\n$parameterGenerator->setType(''); // invalid (throws exception)\n$parameterGenerator->setType('*'); // invalid (throws exception)\n$parameterGenerator->setType('\\\\'); // invalid (throws exception)",
            "title": "Type strings are validated"
        },
        {
            "location": "/migration/#generated-type-hints-are-now-prefixed-by",
            "text": "Generated type-hints are now prefixed with the  NAMESPACE_SEPARATOR , \"\\\" .  Take following example code:  $parameter = new \\Zend\\Code\\Generator\\ParameterGenerator('bar', 'baz');\n$method    = new \\Zend\\Code\\Generator\\MethodGenerator('foo', [$parameter]);\n\n$method->setReturnType('tab');\n\necho $method->generate();  This code produces  public function foo(baz $bar) {}  in 2.x.\nIn version 3.x, it produces  public function foo(\\baz $bar) : \\tab {} .  In order to avoid migration problems, be sure to always pass fully qualified class\nnames to  Zend\\Code\\Generator\\MethodGenerator  and  Zend\\Code\\Generator\\ParameterGenerator .",
            "title": "Generated type-hints are now prefixed by \"\\\""
        },
        {
            "location": "/migration/#parametergeneratorsimple-was-removed",
            "text": "If you extended  Zend\\Code\\Generator\\ParameterGenerator , be sure to check if you\nare accessing the protected static variable  $simple : it was removed, and you should\nadapt your code by either copying it into your class or avoiding its usage.",
            "title": "ParameterGenerator::$simple was removed"
        },
        {
            "location": "/migration/#parametergeneratortype-has-changed",
            "text": "If you extended  Zend\\Code\\Generator\\ParameterGenerator , be sure to check if you\nare accessing the protected variable  $type : its type has changed.\nWhile it can still be used as a string via an explicit  (string)  cast, the type of\nthis protected member is now  null|Zend\\Code\\Generator\\TypeGenerator .",
            "title": "ParameterGenerator::$type has changed"
        }
    ]
}